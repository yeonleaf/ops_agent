#!/usr/bin/env python3
"""
FastMCP 기반 메일 조회 챗봇 앱
기존 chatbot_app.py를 FastMCP 서버와 연동하도록 수정
"""

import streamlit as st
import json
import os
from datetime import datetime
from typing import List, Dict, Any, Optional
from dotenv import load_dotenv
# 쿠키 대신 URL 파라미터와 세션 상태 사용

# 로깅 설정 추가
from module.logging_config import setup_logging
import logging

# 로깅 초기화
setup_logging(level="INFO", log_file="logs/fastmcp_chatbot_app.log", console_output=True)
logger = logging.getLogger(__name__)

# LangChain imports
from langchain_openai import AzureChatOpenAI

# 라우터 에이전트 import
from router_agent import create_router_agent

# 새로운 UI import
from enhanced_ticket_ui_v2 import (
    load_tickets_from_db, 
    display_ticket_button_list, 
    display_ticket_detail
)

# mem0 memory import
from mem0_memory_adapter import create_mem0_memory

# 환경 변수 로드
load_dotenv()

# AI 추천 기능 import
from ticket_ai_recommender import get_ticket_ai_recommendation

# RAG 데이터 관리자 import
from rag_data_manager import create_rag_manager_tab

# 월간보고 JQL 생성기 import
from utils.prompt_parser import generate_jql_from_prompts, display_jql_results

# 인증 관련 import
from auth_client import auth_client
from auth_ui import check_auth_and_show_ui, show_integration_settings

# 프롬프트 관리 import
from models.report_models import DatabaseManager
from services.prompt_service import PromptService

# 프롬프트 DB 초기화
prompt_db_manager = DatabaseManager(os.getenv('REPORTS_DB_PATH', 'reports.db'))
prompt_db_manager.create_tables()

# --- 1. 토큰 복원 로직 (URL 파라미터 → DB 순서) ---
# 세션에 토큰이 없을 때 복원 시도
if 'gmail_access_token' not in st.session_state:
    logger.info("🍪 세션 토큰 없음. 토큰 복원 시도...")
    
    # 1단계: URL 파라미터에서 토큰 확인
    access_token = st.query_params.get('access_token')
    refresh_token = st.query_params.get('refresh_token')
    
    if access_token and refresh_token:
        # URL 파라미터에서 토큰을 받았으면 세션에 저장
        st.session_state['gmail_access_token'] = access_token
        st.session_state['gmail_refresh_token'] = refresh_token
        print("✅ URL 파라미터에서 세션으로 토큰 복원 완료.")
        
        # URL 파라미터 제거 (보안상)
        st.query_params.clear()
    else:
        print("🍪 URL 파라미터에 토큰이 없음 - DB에서 확인 시도...")
        
        # 2단계: DB에서 저장된 refresh_token으로 access_token 재발급 시도
        try:
            from auth_client import auth_client
            if auth_client.is_logged_in():
                print("🔍 DB에서 Google 연동 정보 확인 중...")
                result = auth_client.get_google_integration()
                if result.get("success") and result.get("has_token"):
                    print("✅ DB에 Google 토큰이 저장되어 있음")
                    print("🔄 refresh_token으로 access_token 재발급 시도...")
                    
                    # refresh_token으로 access_token 재발급 시도
                    try:
                        from gmail_provider import refresh_gmail_token
                        refresh_result = refresh_gmail_token()
                        if refresh_result.get("success"):
                            access_token = refresh_result.get("access_token")
                            refresh_token = refresh_result.get("refresh_token")
                            
                            # 세션에 저장
                            st.session_state['gmail_access_token'] = access_token
                            st.session_state['gmail_refresh_token'] = refresh_token
                            print("✅ refresh_token으로 access_token 재발급 성공")
                        else:
                            print("❌ refresh_token으로 access_token 재발급 실패")
                            print("ℹ️ Gmail 기능을 사용하려면 OAuth 인증이 필요합니다.")
                            print("ℹ️ 사이드바의 'Gmail 로그인' 버튼을 클릭하세요.")
                    except Exception as refresh_error:
                        print(f"❌ 토큰 재발급 실패: {refresh_error}")
                        print("ℹ️ Gmail 기능을 사용하려면 OAuth 인증이 필요합니다.")
                        print("ℹ️ 사이드바의 'Gmail 로그인' 버튼을 클릭하세요.")
                else:
                    print("🍪 DB에 Google 토큰이 없음 - 로그인 필요")
            else:
                print("🍪 사용자가 로그인되지 않음 - 로그인 필요")
        except Exception as e:
            print(f"🍪 DB 토큰 확인 실패: {e}")
            print("🍪 로그인 필요")


def create_llm_client():
    """Azure OpenAI LLM 클라이언트 생성"""
    try:
        llm_client = AzureChatOpenAI(
            azure_deployment=os.getenv("AZURE_OPENAI_DEPLOYMENT_NAME"),
            azure_endpoint=os.getenv("AZURE_OPENAI_ENDPOINT"),
            api_key=os.getenv("AZURE_OPENAI_API_KEY"),
            api_version=os.getenv("AZURE_OPENAI_API_VERSION", "2024-10-21"),
            temperature=0.1,
            max_tokens=2000
        )
        print("✅ Azure OpenAI LLM 클라이언트 생성 성공")
        return llm_client
    except Exception as e:
        print(f"❌ LLM 클라이언트 생성 실패: {e}")
        raise e

# 세션 상태 초기화
if 'refresh_trigger' not in st.session_state:
    st.session_state.refresh_trigger = 0

if 'conversation_history' not in st.session_state:
    st.session_state.conversation_history = []

if 'selected_ticket' not in st.session_state:
    st.session_state.selected_ticket = None

if 'llm_client' not in st.session_state:
    st.session_state.llm_client = create_llm_client()

if 'mem0_memory' not in st.session_state:
    # 통일: 커스텀 Mem0 백엔드 사용 (llm_client 미전달) + 동일 user_id
    st.session_state.mem0_memory = create_mem0_memory("ticket_ui")

# mem0 메모리를 전역적으로 사용할 수 있도록 설정
import sys
sys.modules['__main__'].mem0_memory = st.session_state.mem0_memory

if 'auto_switch_to_tickets' not in st.session_state:
    st.session_state.auto_switch_to_tickets = False

if 'ticket_message' not in st.session_state:
    st.session_state.ticket_message = ""

if 'non_work_emails' not in st.session_state:
    st.session_state.non_work_emails = []

# 페이지 설정
st.set_page_config(
    page_title="📧 FastMCP 메일 조회 챗봇",
    page_icon="🤖",
    layout="wide"
)

class RouterAgentClient:
    """라우터 에이전트 클라이언트 래퍼"""
    
    def __init__(self, llm_client):
        self.router_agent = create_router_agent(llm_client)
    
    def call_agent(self, user_query: str, context: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:
        """라우터 에이전트 호출"""
        try:
            # 토큰 가져오기 (URL 파라미터 우선)
            tokens = ""
            try:
                # 1. URL 파라미터에서 토큰 확인 (최우선)
                if hasattr(st, 'query_params'):
                    access_token = st.query_params.get('access_token', '')
                    refresh_token = st.query_params.get('refresh_token', '')
                    print(f"🍪 URL 파라미터 확인: access_token={'있음' if access_token else '없음'}, refresh_token={'있음' if refresh_token else '없음'}")
                    if access_token and refresh_token:
                        # 1. 세션 상태에 저장 (앱의 현재 상태)
                        st.session_state['gmail_access_token'] = access_token
                        st.session_state['gmail_refresh_token'] = refresh_token
                        print(f"🍪 세션 상태에 토큰 저장 완료")
                        
                        # 2. URL 파라미터로 리다이렉트 (영속적 백업)
                        # 토큰을 URL 파라미터로 포함하여 리다이렉트
                        st.rerun()
                        print(f"🍪 URL 파라미터로 토큰 전달 완료")
                        
                        tokens = f"gmail_access_token={access_token}; gmail_refresh_token={refresh_token}"
                        print(f"🍪 URL 파라미터에서 토큰 가져옴: {access_token[:20]}...")
                        # URL 파라미터 제거 (보안상)
                        st.query_params.clear()
                
                # 2. 세션 상태에서 토큰 확인 (진실의 원천)
                if not tokens:
                    print(f"🍪 세션 상태에서 토큰 확인 시도...")
                    access_token = st.session_state.get('gmail_access_token', '')
                    refresh_token = st.session_state.get('gmail_refresh_token', '')
                    print(f"🍪 세션 상태 확인 결과: access_token={'있음' if access_token else '없음'}, refresh_token={'있음' if refresh_token else '없음'}")
                    if access_token and refresh_token:
                        tokens = f"gmail_access_token={access_token}; gmail_refresh_token={refresh_token}"
                        print(f"🍪 세션 상태에서 토큰 가져옴: {access_token[:20]}...")
                    else:
                        print(f"🍪 세션 상태에 토큰이 없음")
                
                if not tokens:
                    print("🍪 토큰을 찾을 수 없음")
                    
            except Exception as e:
                print(f"🍪 토큰 가져오기 실패: {e}")
            
            print(f"🍪 최종 토큰: {tokens[:100] if tokens else '없음'}...")
            
            # 토큰을 라우터 에이전트에 전달
            result = self.router_agent.execute(user_query, cookies=tokens)

            # SpecialistAgent에서 구조화된 데이터를 반환한 경우 처리
            if isinstance(result, dict) and "message" in result:
                return {
                    "success": True,
                    "message": result["message"],
                    "data": {
                        "non_work_emails": result.get("non_work_emails", []),
                        "tickets": result.get("tickets", []),
                        "display_mode": result.get("display_mode", "default")
                    },
                    "tools_used": ["router_agent"],
                    "query": user_query
                }
            else:
                # 기존 문자열 응답 처리
                return {
                    "success": True,
                    "message": result,
                    "data": None,
                    "tools_used": ["router_agent"],
                    "query": user_query
                }
        except Exception as e:
            return {
                "success": False,
                "message": f"에이전트 실행 중 오류가 발생했습니다: {str(e)}",
                "data": None,
                "tools_used": [],
                "error": str(e),
                "query": user_query
            }
    
    def get_server_status(self) -> Dict[str, Any]:
        """서버 상태 확인"""
        return {
            "status": "running",
            "agent_type": "router_agent",
            "available_agents": ["ViewingAgent", "AnalysisAgent", "TicketingAgent"],
            "message": "에이전트 네트워크가 정상적으로 실행 중입니다."
        }

def display_correction_ui(non_work_emails: List[Dict[str, Any]]):
    """업무용이 아니라고 판단된 메일들의 정정 UI를 표시합니다."""
    if not non_work_emails:
        return
    
    st.markdown("---")
    st.markdown("### 🔍 업무용이 아니라고 판단된 메일")
    st.markdown("※ confidence가 높은 메일들입니다. 티켓 생성이 필요하다면 정정 버튼을 클릭하세요.")
    
    for i, email in enumerate(non_work_emails):
        with st.expander(f"📧 {email.get('subject', '제목 없음')} (신뢰도: {email.get('confidence', 0):.2f})"):
            col1, col2 = st.columns([3, 1])
            
            with col1:
                st.markdown(f"**발신자:** {email.get('sender', 'N/A')}")
                st.markdown(f"**수신일:** {email.get('received_date', 'N/A')}")
                st.markdown(f"**판단 근거:** {email.get('reason', 'N/A')}")
                st.markdown(f"**내용 미리보기:** {email.get('body', 'N/A')}")
            
            with col2:
                if st.button(f"정정", key=f"correction_{i}", type="primary"):
                    # 정정 요청 처리
                    try:
                        # 에이전트 경유 대신 서비스 함수를 직접 호출하여 강제 생성 (도구 인자 오류 회피)
                        from unified_email_service import create_ticket_from_single_email
                        email_data = {
                            'id': email.get('id'),
                            'subject': email.get('subject'),
                            'sender': email.get('sender'),
                            'body': email.get('body')
                        }
                        result = create_ticket_from_single_email(
                            email_data=email_data,
                            access_token=st.session_state.get('gmail_access_token', ''),
                            force_create=True,
                            correction_reason="사용자 정정: 비업무로 분류된 메일을 업무용으로 처리"
                        )
                        if result.get('success'):
                            st.success("✅ 정정 완료! 티켓이 생성되었습니다.")
                            st.info(f"티켓 ID: {result.get('ticket_id')}")
                        else:
                            st.error(f"❌ 정정 실패: {result.get('error', '알 수 없는 오류')}")
                        
                        # non_work_emails에서 해당 메일 제거
                        if hasattr(st.session_state, 'non_work_emails') and st.session_state.non_work_emails:
                            st.session_state.non_work_emails = [
                                e for e in st.session_state.non_work_emails 
                                if e.get('id') != email.get('id')
                            ]
                            
                            # 모든 메일이 정정된 경우 목록 초기화
                            if not st.session_state.non_work_emails:
                                st.session_state.has_non_work_emails = False
                        
                        # 세션 상태 업데이트
                        st.session_state.refresh_trigger += 1
                        st.rerun()
                        
                    except Exception as e:
                        st.error(f"❌ 정정 실패: {str(e)}")

class AgentNetworkChatBot:
    """에이전트 네트워크 기반 챗봇 클래스"""
    
    def __init__(self, llm_client):
        self.router_client = RouterAgentClient(llm_client)
        self.conversation_history = st.session_state.conversation_history
    
    def process_user_input(self, user_input: str) -> str:
        """사용자 입력 처리"""
        try:
            # 라우터 에이전트 호출
            result = self.router_client.call_agent(user_input)

            # 응답 메시지 가져오기
            response_message = result.get("message", "응답을 생성할 수 없습니다.")

            # SpecialistAgent에서 이미 세션 상태에 저장됨

            # 티켓 관련 요청인지 확인하고 간단한 메시지로 변경
            simplified_message, should_switch = self._process_ticket_response(user_input, response_message, result.get("data"))
            
            # 대화 기록에 추가
            self.conversation_history.append({
                "timestamp": datetime.now().isoformat(),
                "user": user_input,
                "assistant": simplified_message,
                "success": result.get("success", False),
                "tools_used": result.get("tools_used", []),
                "data": result.get("data")
            })
            
            # 세션 상태 업데이트
            st.session_state.conversation_history = self.conversation_history
            
            # 티켓 관리 탭으로 자동 전환 설정
            if should_switch:
                st.session_state.auto_switch_to_tickets = True
                st.session_state.ticket_message = simplified_message
            
            return simplified_message
            
        except Exception as e:
            error_message = f"입력 처리 중 오류가 발생했습니다: {str(e)}"
            self.conversation_history.append({
                "timestamp": datetime.now().isoformat(),
                "user": user_input,
                "assistant": error_message,
                "success": False,
                "tools_used": [],
                "data": None
            })
            return error_message
    
    def _process_ticket_response(self, user_input: str, response_message: str, data: Dict[str, Any] = None) -> tuple[str, bool]:
        """티켓 관련 응답을 처리하고 간단한 메시지로 변경"""
        user_input_lower = user_input.lower()
        
        # 티켓 관련 키워드 확인 (OAuth 인증이 필요한 이메일 조회는 제외)
        ticket_keywords = [
            "티켓", "ticket", "메일 처리", "메일 가져와서", 
            "티켓으로", "티켓 만들어", "티켓 생성", "티켓 조회", "티켓 보여"
        ]
        
        is_ticket_request = any(keyword in user_input_lower for keyword in ticket_keywords)
        
        # OAuth 인증 메시지인지 확인 (OAuth 인증 메시지는 그대로 반환)
        oauth_keywords = ["인증", "oauth", "gmail", "로그인", "권한", "승인"]
        is_oauth_message = any(keyword in response_message.lower() for keyword in oauth_keywords)
        
        if is_oauth_message:
            # OAuth 인증 메시지는 그대로 반환
            return response_message, False
        
        if is_ticket_request:
            # 티켓 생성 요청인지 확인
            if any(keyword in user_input_lower for keyword in ["만들어", "생성", "처리", "가져와서"]):
                # SpecialistAgent에서 이미 세션 상태 처리 완료
                return "✅ 티켓 생성 요청을 처리했습니다. 티켓 관리 탭에서 결과를 확인하세요.", True
            
            # 티켓 조회 요청인지 확인
            elif any(keyword in user_input_lower for keyword in ["조회", "보여", "보여줘", "확인"]):
                return "✅ 티켓 조회 요청을 처리했습니다. 티켓 관리 탭에서 티켓 목록을 확인하세요.", True
            
            # 기타 티켓 관련 요청
            else:
                return "✅ 티켓 관련 요청을 처리했습니다. 티켓 관리 탭에서 결과를 확인하세요.", True
        
        # 티켓 관련 요청이 아닌 경우 원본 응답 반환
        return response_message, False
    
    def get_conversation_history(self) -> List[Dict[str, Any]]:
        """대화 기록 반환"""
        return self.conversation_history
    
    def clear_conversation(self):
        """대화 기록 초기화"""
        self.conversation_history = []
        st.session_state.conversation_history = []

def main():
    """메인 애플리케이션"""

    print(f"🍪 main() 함수 시작")
    print(f"🍪 check_auth_and_show_ui() 호출 전")

    # 인증 체크 - 로그인하지 않은 사용자는 인증 UI만 표시
    if not check_auth_and_show_ui():
        print(f"🍪 인증 실패 - main() 함수 종료")
        return

    print(f"🍪 인증 성공 - 온보딩 체크 시작")

    # 온보딩 완료 여부 확인
    if 'onboarding_completed' not in st.session_state:
        st.session_state.onboarding_completed = False

    # 온보딩 미완료 시 온보딩 화면만 표시
    if not st.session_state.onboarding_completed:
        print(f"🚀 온보딩 미완료 - 온보딩 UI 표시")
        from onboarding_ui import show_onboarding_process

        # 현재 로그인된 사용자 이메일 가져오기
        user_email = st.session_state.get('user_email', '')

        # 온보딩 프로세스 표시
        is_complete = show_onboarding_process(user_email)

        # 온보딩 완료 시 세션 상태 업데이트
        if is_complete and st.session_state.get('onboarding_completed', False):
            print(f"✅ 온보딩 완료 - 메인 UI로 이동")
            st.rerun()

        return

    print(f"🍪 온보딩 완료 - 메인 UI 표시")

    # 제목
    st.title("🤖 에이전트 네트워크 메일 챗봇")

    st.markdown("---")

    # 챗봇 인스턴스 생성
    chatbot = AgentNetworkChatBot(st.session_state.llm_client)

    # 탭 생성
    tab1, tab2, tab3, tab4 = st.tabs(["💬 AI 챗봇", "🎫 티켓 관리", "📚 RAG 데이터 관리자", "📊 월간보고"])

    # 자동 탭 전환 처리
    if st.session_state.auto_switch_to_tickets:
        st.session_state.auto_switch_to_tickets = False
        st.success(st.session_state.ticket_message)
        st.info("🎫 티켓 관리 탭으로 이동합니다...")
        st.rerun()

    with tab1:
        display_chat_interface(chatbot)

    with tab2:
        display_ticket_management_with_async()

    with tab3:
        create_rag_manager_tab()

    with tab4:
        display_monthly_report_tab()


def display_chat_interface(chatbot):
    """채팅 인터페이스 표시"""
    # 메인 채팅 인터페이스
    col1, col2 = st.columns([3, 1])
    
    with col1:
        st.header("💬 채팅")
        
        # 디버깅: 세션 상태 확인
        st.markdown("### 🔍 디버깅 정보")
        st.write(f"**non_work_emails 존재**: {hasattr(st.session_state, 'non_work_emails')}")
        st.write(f"**non_work_emails 개수**: {len(st.session_state.get('non_work_emails', []))}")
        st.write(f"**has_non_work_emails**: {st.session_state.get('has_non_work_emails', False)}")

        if hasattr(st.session_state, 'non_work_emails') and st.session_state.non_work_emails:
            st.write(f"**첫 번째 메일 제목**: {st.session_state.non_work_emails[0].get('subject', 'N/A')}")

        # non_work_emails가 있는 경우 새로운 UI로 표시
        if hasattr(st.session_state, 'non_work_emails') and st.session_state.non_work_emails:
            st.markdown("---")
            st.success(f"✅ {len(st.session_state.non_work_emails)}개의 업무용이 아닌 메일을 표시합니다.")

            # 새로운 non_work_emails_ui 사용
            try:
                from non_work_emails_ui import display_non_work_emails
                display_non_work_emails(st.session_state.non_work_emails)
                st.success("✅ non_work_emails_ui 모듈 로드 성공")
            except Exception as e:
                st.error(f"❌ non_work_emails_ui 로드 실패: {e}")
                st.exception(e)

            # 지우기 버튼도 추가
            col_clear1, col_clear2 = st.columns([3, 1])
            with col_clear2:
                if st.button("🗑️ 목록 지우기", key="clear_non_work_emails"):
                    st.session_state.non_work_emails = []
                    st.session_state.has_non_work_emails = False
                    # 이메일 캐시도 초기화
                    from unified_email_service import clear_email_cache
                    clear_email_cache()
                    st.rerun()
        else:
            st.info("📧 현재 업무용이 아닌 메일이 없습니다.")
        
        # 대화 기록 표시
        for i, message in enumerate(chatbot.get_conversation_history()):
            with st.expander(f"💬 대화 {i+1} - {message['timestamp'][:19]}"):
                st.markdown(f"**👤 사용자:** {message['user']}")
                
                # 어시스턴트 응답 표시 (non_work_emails가 포함된 경우 특별 처리)
                assistant_response = message['assistant']
                if "업무용이 아니라고 판단된 메일" in assistant_response:
                    # non_work_emails가 포함된 응답인 경우 마크다운으로 렌더링
                    st.markdown(assistant_response)
                else:
                    st.markdown(f"**🤖 어시스턴트:** {assistant_response}")
                
                if message.get('tools_used'):
                    st.markdown(f"**🛠️ 사용된 도구:** {', '.join(message['tools_used'])}")
                
                if message.get('data'):
                    with st.expander("📊 상세 데이터"):
                        st.json(message['data'])
                
                if not message.get('success', True):
                    st.error("❌ 처리 실패")
    
    with col2:
        st.header("📝 새 메시지")
        
        # 사용자 입력
        user_input = st.text_area(
            "메시지를 입력하세요:",
            height=100,
            placeholder="예: 안 읽은 메일을 처리해주세요"
        )
        
        # 전송 버튼
        if st.button("📤 전송", type="primary"):
            if user_input.strip():
                with st.spinner("처리 중..."):
                    response = chatbot.process_user_input(user_input)
                    st.success("응답이 생성되었습니다!")
                    st.rerun()
            else:
                st.warning("메시지를 입력해주세요.")
        
        # 빠른 명령어 버튼들
        st.markdown("**🚀 빠른 명령어:**")
        
        quick_commands = [
            "최근 메일을 가져와서 티켓을 생성해주세요",
            "안 읽은 메일 3개만 가져와서 보여주세요"
        ]
        
        for cmd in quick_commands:
            if st.button(f"📌 {cmd}", key=f"quick_{cmd}"):
                with st.spinner("처리 중..."):
                    response = chatbot.process_user_input(cmd)
                    st.success("응답이 생성되었습니다!")
                    st.rerun()
    
    # 푸터
    st.markdown("---")
    st.markdown("**FastMCP 기반 이메일 서비스 챗봇** | 🤖 AI-Powered Email Management")

def display_ticket_management():
    """티켓 관리 인터페이스 표시"""
    st.header("🎫 티켓 관리 시스템")
    
    # 새로고침 버튼
    col1, col2, col3 = st.columns([1, 1, 3])
    with col1:
        if st.button("🔄 새로고침"):
            st.session_state.refresh_trigger += 1
            st.rerun()
    
    with col2:
        if st.button("🤖 전체 AI 추천"):
            with st.spinner("모든 티켓에 대한 AI 추천을 생성하고 있습니다..."):
                tickets = load_tickets_from_db()
                if tickets:
                    recommendations = []
                    for ticket in tickets[:3]:  # 최대 3개 티켓만 처리
                        recommendation = get_ticket_ai_recommendation(ticket.ticket_id)
                        if recommendation.get("success"):
                            recommendations.append({
                                "ticket_id": ticket.ticket_id,
                                "title": ticket.title,
                                "recommendation": recommendation.get("recommendation", "")
                            })
                    
                    if recommendations:
                        st.session_state["bulk_recommendations"] = recommendations
                        st.success(f"✅ {len(recommendations)}개 티켓의 AI 추천이 생성되었습니다!")
                    else:
                        st.warning("AI 추천을 생성할 수 없습니다.")
                else:
                    st.info("추천할 티켓이 없습니다.")
    
    # 정정 UI 표시 (non_work_emails가 있는 경우)
    if hasattr(st.session_state, 'has_non_work_emails') and st.session_state.has_non_work_emails:
        # 세션 상태에 저장된 non_work_emails 데이터 사용 (중복 실행 방지)
        non_work_emails = st.session_state.get('non_work_emails', [])
        if non_work_emails:
            display_correction_ui(non_work_emails)
    
    
    # 대량 AI 추천 결과 표시
    if "bulk_recommendations" in st.session_state:
        st.subheader("🤖 전체 AI 추천 결과")
        recommendations = st.session_state["bulk_recommendations"]
        
        for rec in recommendations:
            with st.expander(f"🎫 티켓 #{rec['ticket_id']}: {rec['title']}", expanded=False):
                st.markdown(rec["recommendation"])
        
        if st.button("🗑️ 추천 결과 지우기"):
            del st.session_state["bulk_recommendations"]
            st.rerun()
    
    # 티켓 목록 또는 상세 보기
    if st.session_state.selected_ticket:
        display_ticket_detail(st.session_state.selected_ticket)
    else:
        # 티켓 목록 표시
        tickets = load_tickets_from_db()
        st.session_state.tickets = tickets
        display_ticket_button_list(tickets)

def display_ticket_management_with_async():
    """비동기 기능이 통합된 티켓 관리 인터페이스"""
    st.header("🎫 티켓 관리 시스템 (비동기 지원)")

    # 비동기 티켓 생성 섹션 추가
    try:
        from async_ticket_mcp_ui import display_async_ticket_section
        display_async_ticket_section()
    except Exception as e:
        st.error(f"❌ 비동기 티켓 UI 로드 실패: {e}")
        st.info("기존 동기식 티켓 관리만 사용 가능합니다.")

    # 기존 티켓 관리 기능 유지
    st.markdown("---")
    st.subheader("📋 기존 티켓 관리")

    # 새로고침 버튼
    col1, col2, col3 = st.columns([1, 1, 3])
    with col1:
        if st.button("🔄 새로고침", key="legacy_refresh"):
            st.session_state.refresh_trigger += 1
            st.rerun()

    with col2:
        if st.button("🤖 전체 AI 추천", key="legacy_ai_recommend"):
            with st.spinner("모든 티켓에 대한 AI 추천을 생성하고 있습니다..."):
                tickets = load_tickets_from_db()
                if tickets:
                    recommendations = []
                    for ticket in tickets[:3]:  # 최대 3개 티켓만 처리
                        recommendation = get_ticket_ai_recommendation(ticket.ticket_id)
                        if recommendation.get("success"):
                            recommendations.append({
                                "ticket_id": ticket.ticket_id,
                                "title": ticket.title,
                                "recommendation": recommendation.get("recommendation", "")
                            })

                    if recommendations:
                        st.session_state["bulk_recommendations"] = recommendations
                        st.success(f"✅ {len(recommendations)}개 티켓의 AI 추천이 생성되었습니다!")
                    else:
                        st.info("추천할 티켓이 없습니다.")
                else:
                    st.info("추천할 티켓이 없습니다.")

    # 정정 UI 표시 (non_work_emails가 있는 경우)
    if hasattr(st.session_state, 'has_non_work_emails') and st.session_state.has_non_work_emails:
        # 세션 상태에 저장된 non_work_emails 데이터 사용 (중복 실행 방지)
        non_work_emails = st.session_state.get('non_work_emails', [])
        if non_work_emails:
            display_correction_ui(non_work_emails)

    # 대량 AI 추천 결과 표시
    if "bulk_recommendations" in st.session_state:
        st.subheader("🤖 전체 AI 추천 결과")
        recommendations = st.session_state["bulk_recommendations"]

        for rec in recommendations:
            with st.expander(f"🎫 티켓 #{rec['ticket_id']}: {rec['title']}", expanded=False):
                st.markdown(rec["recommendation"])

        if st.button("🗑️ 추천 결과 지우기", key="clear_bulk_recommendations"):
            del st.session_state["bulk_recommendations"]
            st.rerun()

    # 티켓 목록 또는 상세 보기
    if st.session_state.selected_ticket:
        display_ticket_detail(st.session_state.selected_ticket)
    else:
        # 티켓 목록 표시
        tickets = load_tickets_from_db()
        st.session_state.tickets = tickets
        display_ticket_button_list(tickets)

def display_monthly_report_tab():
    """월간보고 JQL 생성기 탭"""
    st.title("📊 월간보고 JQL 생성기")

    # 서브탭 추가: 월간보고 생성 / 그룹 관리 / 그룹 보고서 / Jira 디버깅
    subtab1, subtab2, subtab3, subtab4 = st.tabs([
        "📊 월간보고 생성",
        "👥 그룹 관리",
        "📊 그룹 보고서",
        "🔍 Jira 디버깅"
    ])

    with subtab1:
        display_monthly_report_generation()

    with subtab2:
        display_group_management()

    with subtab3:
        display_group_report_builder()

    with subtab4:
        display_jira_debugging()


# ============================================================
# 프롬프트 관리 함수들
# ============================================================

def get_prompt_service():
    """PromptService 인스턴스 생성"""
    session = prompt_db_manager.get_session()
    return PromptService(session), session


def save_prompt_template(prompt_content: str, template_title: str, category: str = "월간보고",
                        group_id: int = None, system: str = None):
    """프롬프트 템플릿 저장 (단순 텍스트)"""
    if not auth_client.is_logged_in():
        st.error("⚠️ 로그인이 필요합니다")
        return False

    user_id = st.session_state.get('user_id')
    if not user_id:
        st.error("⚠️ 사용자 정보를 가져올 수 없습니다")
        return False

    prompt_service, session = get_prompt_service()

    try:
        prompt_data = {
            'title': template_title,
            'category': category,
            'description': '프롬프트 템플릿',
            'prompt_content': prompt_content,
            'is_public': False,
            'order_index': 999,
            'group_id': group_id,
            'system': system
        }

        prompt_id = prompt_service.create_prompt(user_id, prompt_data)

        group_info = f" (그룹 프롬프트 - 시스템: {system})" if group_id else ""
        st.success(f"✅ 프롬프트 템플릿 '{template_title}'이(가) 저장되었습니다{group_info} (ID: {prompt_id})")
        return True
    except Exception as e:
        st.error(f"❌ 저장 중 오류 발생: {str(e)}")
        return False
    finally:
        session.close()


def save_current_prompts_to_template(pages_data: List[Dict], template_title: str, category: str = "월간보고",
                                     group_id: int = None, system: str = None):
    """현재 입력된 프롬프트들을 템플릿으로 저장"""
    if not auth_client.is_logged_in():
        st.error("⚠️ 로그인이 필요합니다")
        return False

    user_id = st.session_state.get('user_id')
    if not user_id:
        st.error("⚠️ 사용자 정보를 가져올 수 없습니다")
        return False

    prompt_service, session = get_prompt_service()

    try:
        # 여러 페이지를 하나의 템플릿으로 저장 (JSON 형식)
        prompt_content = json.dumps(pages_data, ensure_ascii=False, indent=2)

        prompt_data = {
            'title': template_title,
            'category': category,
            'description': f'{len(pages_data)}개 페이지 포함',
            'prompt_content': prompt_content,
            'is_public': False,
            'order_index': 999,
            'group_id': group_id,
            'system': system
        }

        prompt_id = prompt_service.create_prompt(user_id, prompt_data)

        group_info = f" (그룹 프롬프트 - 시스템: {system})" if group_id else ""
        st.success(f"✅ 프롬프트 템플릿 '{template_title}'이(가) 저장되었습니다{group_info} (ID: {prompt_id})")
        return True
    except Exception as e:
        st.error(f"❌ 저장 중 오류 발생: {str(e)}")
        return False
    finally:
        session.close()


def load_saved_prompts(group_id=None, category=None):
    """저장된 프롬프트 템플릿 목록 가져오기

    Args:
        group_id: 그룹 ID (None이면 개인 프롬프트만)
        category: 카테고리 이름 (None이면 모든 카테고리)
    """
    if not auth_client.is_logged_in():
        return []

    user_id = st.session_state.get('user_id')
    if not user_id:
        return []

    prompt_service, session = get_prompt_service()

    try:
        result = prompt_service.get_user_prompts(user_id, include_public=False)
        my_prompts = result.get('my_prompts', [])

        # 그룹 필터링
        if group_id is not None:
            # 특정 그룹의 프롬프트만
            my_prompts = [p for p in my_prompts if p.get('group_id') == group_id]
        else:
            # 개인 프롬프트만 (group_id가 None인 것)
            my_prompts = [p for p in my_prompts if p.get('group_id') is None]

        # 카테고리 필터링
        if category is not None:
            my_prompts = [p for p in my_prompts if p.get('category') == category]

        return my_prompts
    except Exception as e:
        st.error(f"❌ 프롬프트 불러오기 실패: {str(e)}")
        return []
    finally:
        session.close()


def load_prompt_by_id(prompt_id: int):
    """특정 프롬프트 템플릿 불러오기"""
    if not auth_client.is_logged_in():
        return None

    user_id = st.session_state.get('user_id')
    if not user_id:
        return None

    prompt_service, session = get_prompt_service()

    try:
        prompt = prompt_service.get_prompt_by_id(prompt_id, user_id)
        if prompt:
            return prompt.to_dict(include_content=True)
        return None
    except Exception as e:
        st.error(f"❌ 프롬프트 불러오기 실패: {str(e)}")
        return None
    finally:
        session.close()


def delete_prompt_template(prompt_id: int):
    """프롬프트 템플릿 삭제"""
    if not auth_client.is_logged_in():
        st.error("⚠️ 로그인이 필요합니다")
        return False

    user_id = st.session_state.get('user_id')
    if not user_id:
        st.error("⚠️ 사용자 정보를 가져올 수 없습니다")
        return False

    prompt_service, session = get_prompt_service()

    try:
        prompt_service.delete_prompt(user_id, prompt_id)
        st.success("✅ 프롬프트 템플릿이 삭제되었습니다")
        return True
    except Exception as e:
        st.error(f"❌ 삭제 중 오류 발생: {str(e)}")
        return False
    finally:
        session.close()


def update_prompt_template(prompt_id: int, template_title: str, category: str, prompt_content: str):
    """프롬프트 템플릿 수정"""
    if not auth_client.is_logged_in():
        st.error("⚠️ 로그인이 필요합니다")
        return False

    user_id = st.session_state.get('user_id')
    if not user_id:
        st.error("⚠️ 사용자 정보를 가져올 수 없습니다")
        return False

    prompt_service, session = get_prompt_service()

    try:
        # 프롬프트 업데이트
        update_data = {
            'title': template_title,
            'category': category,
            'description': '프롬프트 템플릿',
            'prompt_content': prompt_content
        }

        prompt_service.update_prompt(user_id, prompt_id, update_data)

        st.success(f"✅ 프롬프트 템플릿 '{template_title}'이(가) 수정되었습니다")
        return True
    except Exception as e:
        st.error(f"❌ 수정 중 오류 발생: {str(e)}")
        return False
    finally:
        session.close()


def display_monthly_report_generation():
    """월간보고 생성 UI (그룹 전용)"""
    # 그룹 선택 섹션
    st.header("📁 그룹 선택")

    selected_group_id = None
    selected_group_name = None

    groups_result = auth_client.get_groups()
    if groups_result.get("success"):
        available_groups = groups_result.get("groups", [])
        if available_groups:
            group_options = {g['id']: f"📁 {g['name']} ({g['role']})" for g in available_groups}
            selected_group_id = st.selectbox(
                "작업할 그룹을 선택하세요",
                options=list(group_options.keys()),
                format_func=lambda x: group_options[x],
                key="monthly_selected_group",
                help="선택한 그룹의 프롬프트와 카테고리를 사용합니다"
            )
            # 선택된 그룹 이름 저장
            for g in available_groups:
                if g['id'] == selected_group_id:
                    selected_group_name = g['name']
                    break
        else:
            st.warning("⚠️ 속한 그룹이 없습니다. 그룹 관리 탭에서 그룹을 생성하거나 참여하세요.")
            st.stop()
    else:
        st.error("그룹 목록을 불러올 수 없습니다.")
        st.stop()

    # 카테고리 선택
    selected_category = None
    if selected_group_id:
        st.subheader("📂 카테고리 선택")
        categories_result = auth_client.get_group_categories(selected_group_id)
        if categories_result.get("success"):
            group_categories = categories_result.get("categories", [])
            if group_categories:
                category_options = ["전체 보기"] + [cat['name'] for cat in group_categories]
                selected_category_display = st.selectbox(
                    "작업할 카테고리를 선택하세요",
                    options=category_options,
                    key="monthly_selected_category",
                    help="선택한 카테고리의 프롬프트만 표시됩니다"
                )
                # "전체 보기"가 아닐 때만 카테고리 설정
                if selected_category_display != "전체 보기":
                    selected_category = selected_category_display

                st.info(f"📂 현재 카테고리: **{selected_category_display}**")
            else:
                st.warning("⚠️ 이 그룹에는 카테고리가 없습니다. 그룹 관리자에게 카테고리 추가를 요청하세요.")
        else:
            st.error("카테고리 목록을 불러올 수 없습니다.")

    st.divider()

    # 자동으로 그룹-카테고리의 기존 프롬프트 로드
    existing_prompt = None
    existing_prompt_id = None

    if selected_group_id and selected_category:
        # 해당 그룹-카테고리의 프롬프트 조회
        saved_prompts = load_saved_prompts(group_id=selected_group_id, category=selected_category)
        if saved_prompts:
            # 1:1 구조이므로 첫 번째 프롬프트 사용
            existing_prompt = saved_prompts[0]
            existing_prompt_id = existing_prompt['id']

            # 프롬프트 내용 로드
            prompt_data = load_prompt_by_id(existing_prompt_id)
            if prompt_data:
                existing_prompt_content = prompt_data['prompt_content']
                st.info(f"💡 기존 프롬프트를 불러왔습니다: **{existing_prompt['title']}** (시스템: {existing_prompt.get('system', 'N/A')})")
            else:
                existing_prompt_content = ""
        else:
            existing_prompt_content = ""
    else:
        existing_prompt_content = ""

    # 프롬프트 입력 섹션
    st.header("📝 프롬프트 작성")

    # 단일 텍스트박스로 프롬프트 입력 (기존 내용 자동 로드)
    prompt_content = st.text_area(
        "프롬프트 내용",
        value=existing_prompt_content,
        height=400,
        key=f"prompt_content_{selected_group_id}_{selected_category}",
        placeholder="""예시:
# 2024년 10월 월간보고

## 1. 주요 업무 현황
- BTVO 프로젝트 상용 DB 작업: user1, NCMS_상용작업(DB) 라벨
- 시스템 업그레이드: user2, Database 컴포넌트

## 2. 완료 이슈
- 프로젝트: BTVO
- 기간: 2024-10-01 ~ 2024-10-31
- 상태: 완료

## 3. 진행 중 이슈
...
        """,
        help="마크다운 형식으로 작성하면 구조화된 프롬프트를 만들 수 있습니다"
    )


    # 저장 섹션
    if auth_client.is_logged_in() and selected_category:
        st.divider()
        st.header("💾 저장")

        # 현재 작업 정보 표시
        st.info(f"📁 **{selected_group_name}** > 📂 **{selected_category}**")

        # 담당 시스템 입력
        default_system = existing_prompt.get('system', '') if existing_prompt else ''
        prompt_system = st.text_input(
            "담당 시스템",
            value=default_system,
            placeholder="예: NCMS, EUXP, EDMP",
            key="prompt_system_input",
            help="그룹 보고서 생성 시 시스템별로 정렬됩니다"
        )

        # 저장 버튼
        col_save1, col_save2, col_save3 = st.columns([1, 2, 1])
        with col_save2:
            if st.button("💾 저장하기", use_container_width=True, key="save_prompt_btn", type="primary"):
                if not prompt_content.strip():
                    st.error("⚠️ 프롬프트 내용을 입력해주세요")
                else:
                    # 템플릿 이름 자동 생성
                    template_title = f"{selected_group_name} - {selected_category}"
                    system_to_save = prompt_system.strip() if prompt_system and prompt_system.strip() else None

                    # 기존 프롬프트가 있으면 update, 없으면 create
                    if existing_prompt_id:
                        # Update
                        if update_prompt_template(existing_prompt_id, template_title, selected_category, prompt_content):
                            st.success("✅ 프롬프트가 업데이트되었습니다")
                            st.rerun()
                    else:
                        # Create
                        if save_prompt_template(
                            prompt_content,
                            template_title,
                            selected_category,
                            selected_group_id,
                            system_to_save
                        ):
                            st.rerun()


def display_group_management():
    """보고서 빌더 - 저장된 프롬프트를 선택하여 일괄 실행하고 조합"""
    if not auth_client.is_logged_in():
        st.warning("⚠️ 로그인이 필요합니다")
        return

    # 세션 상태 초기화
    if 'builder_sections' not in st.session_state:
        st.session_state.builder_sections = []
    if 'selected_prompts' not in st.session_state:
        st.session_state.selected_prompts = set()
    if 'section_id_counter' not in st.session_state:
        st.session_state.section_id_counter = 1

    # 레이아웃: 2열
    col_left, col_right = st.columns([1, 2])

    # ========================================
    # 왼쪽: 템플릿 선택
    # ========================================
    with col_left:
        st.subheader("📝 템플릿 선택")

        # 새로고침 버튼
        if st.button("🔄 새로고침", key="refresh_builder_prompts"):
            st.rerun()

        # 저장된 템플릿 불러오기
        saved_prompts = load_saved_prompts()

        if not saved_prompts:
            st.info("💡 저장된 템플릿이 없습니다")
        else:
            # 카테고리별 그룹핑
            grouped = {}
            for prompt in saved_prompts:
                category = prompt.get('category', '기타')
                if category not in grouped:
                    grouped[category] = []
                grouped[category].append(prompt)

            # 카테고리별로 표시
            for category, prompts in grouped.items():
                st.markdown(f"**{category}**")

                for prompt in prompts:
                    prompt_id = prompt['id']
                    is_selected = prompt_id in st.session_state.selected_prompts

                    if st.checkbox(
                        prompt['title'],
                        value=is_selected,
                        key=f"builder_prompt_{prompt_id}"
                    ):
                        st.session_state.selected_prompts.add(prompt_id)
                    else:
                        st.session_state.selected_prompts.discard(prompt_id)

                st.markdown("---")

            # 일괄 실행 버튼
            selected_count = len(st.session_state.selected_prompts)

            if st.button(
                f"▶️ 선택한 템플릿 실행 ({selected_count}개)",
                type="primary",
                disabled=selected_count == 0,
                use_container_width=True,
                key="execute_builder_prompts"
            ):
                execute_selected_prompts(list(st.session_state.selected_prompts))

            if selected_count > 0:
                st.caption("💡 각 템플릿의 모든 페이지가 실행됩니다 (2초 간격)")

    # ========================================
    # 오른쪽: 실행 결과 & 조합
    # ========================================
    with col_right:
        st.subheader("📊 실행 결과 & 조합")

        # 컴포넌트 추가 메뉴
        st.markdown("### ➕ 컴포넌트 추가")
        col_add1, col_add2, col_add3, col_add4 = st.columns(4)

        with col_add1:
            if st.button("📝 텍스트", use_container_width=True, key="add_text"):
                add_text_block()
                st.rerun()

        with col_add2:
            if st.button("📊 빈 표", use_container_width=True, key="add_table"):
                add_empty_table()
                st.rerun()

        with col_add3:
            if st.button("➖ 구분선", use_container_width=True, key="add_divider"):
                add_divider()
                st.rerun()

        with col_add4:
            if st.button("📄 페이지 구분", use_container_width=True, key="add_page_break"):
                add_page_break()
                st.rerun()

        st.divider()

        if len(st.session_state.builder_sections) == 0:
            st.info("""
📋 섹션이 없습니다

- 왼쪽에서 템플릿을 선택하고 실행하거나
- 위 버튼으로 컴포넌트를 추가하세요
            """)
        else:
            # 실행 결과 표시
            st.success(f"✅ {len(st.session_state.builder_sections)}개 페이지 실행 완료")

            # 각 섹션 표시 (타입별로 다른 렌더링)
            for idx, section in enumerate(st.session_state.builder_sections):
                section_type = section.get('type', 'prompt')

                # 타입별 렌더링
                if section_type == 'prompt':
                    render_prompt_section(idx, section)
                elif section_type == 'text':
                    render_text_section(idx, section)
                elif section_type == 'table':
                    render_table_section(idx, section)
                elif section_type == 'divider':
                    render_divider_section(idx, section)
                elif section_type == 'page_break':
                    render_page_break_section(idx, section)

                st.divider()

            # 보고서 설정
            st.markdown("### ⚙️ 보고서 설정")

            report_title = st.text_input(
                "보고서 제목",
                value="월간보고",
                key="builder_report_title"
            )

            include_toc = st.checkbox(
                "목차 포함",
                value=True,
                key="builder_include_toc"
            )

            # 최종 생성 버튼
            col_preview, col_generate = st.columns(2)

            with col_preview:
                if st.button("👁️ 미리보기", use_container_width=True, key="builder_preview"):
                    html = generate_final_html(
                        st.session_state.builder_sections,
                        report_title,
                        include_toc
                    )

                    # 모달처럼 표시 (iframe)
                    st.markdown("#### 미리보기")
                    st.components.v1.html(html, height=600, scrolling=True)

            with col_generate:
                if st.button("💾 생성 & 다운로드", type="primary", use_container_width=True, key="builder_generate"):
                    html = generate_final_html(
                        st.session_state.builder_sections,
                        report_title,
                        include_toc
                    )

                    # 다운로드 버튼
                    st.download_button(
                        label="📥 HTML 다운로드",
                        data=html,
                        file_name=f"{report_title}.html",
                        mime="text/html",
                        use_container_width=True
                    )

                    st.success("✅ 보고서가 생성되었습니다!")


def execute_selected_prompts(prompt_ids: List[int]):
    """선택한 템플릿들을 일괄 실행 (각 템플릿의 모든 페이지 실행)"""
    if not prompt_ids:
        return

    import time

    # 프롬프트 정보 가져오기
    prompt_service, session = get_prompt_service()
    user_id = st.session_state.get('user_id')

    try:
        prompts = prompt_service.get_prompts_by_ids(prompt_ids, user_id)
        prompt_map = {p.id: p for p in prompts}

        # Agent 초기화
        from openai import AzureOpenAI

        azure_client = AzureOpenAI(
            api_key=os.environ.get("AZURE_OPENAI_API_KEY") or st.secrets.get("AZURE_OPENAI_API_KEY"),
            api_version="2024-02-15-preview",
            azure_endpoint=os.environ.get("AZURE_OPENAI_ENDPOINT") or st.secrets.get("AZURE_OPENAI_ENDPOINT")
        )

        from agent.monthly_report_agent import MonthlyReportAgent

        agent = MonthlyReportAgent(
            azure_client=azure_client,
            user_id=user_id,
            deployment_name=os.environ.get("AZURE_OPENAI_DEPLOYMENT_NAME") or st.secrets.get("AZURE_OPENAI_DEPLOYMENT_NAME", "gpt-4")
        )

        # 전체 페이지 수 계산
        total_pages = 0
        template_pages = {}  # {template_id: [pages]}

        for prompt_id in prompt_ids:
            prompt = prompt_map.get(prompt_id)
            if not prompt:
                continue

            try:
                pages_data = json.loads(prompt.prompt_content)
                if isinstance(pages_data, list):
                    template_pages[prompt_id] = pages_data
                    total_pages += len(pages_data)
                else:
                    # JSON이 아니거나 단일 프롬프트인 경우
                    template_pages[prompt_id] = [{'title': prompt.title, 'prompt': prompt.prompt_content}]
                    total_pages += 1
            except:
                # JSON 파싱 실패 시 단일 프롬프트로 처리
                template_pages[prompt_id] = [{'title': prompt.title, 'prompt': prompt.prompt_content}]
                total_pages += 1

        # 실행
        success_count = 0
        current_page = 0

        progress_bar = st.progress(0)
        status_text = st.empty()

        for template_id, pages in template_pages.items():
            template = prompt_map.get(template_id)
            template_name = template.title if template else f"템플릿 {template_id}"

            for page_idx, page in enumerate(pages):
                current_page += 1
                page_title = page.get('title', f"{template_name} - 페이지 {page_idx + 1}")
                page_prompt = page.get('prompt', '')

                # 시스템 지시사항 자동 추가
                enhanced_prompt = f"""{page_prompt}

[중요 출력 규칙]
- 반드시 HTML 형식으로 출력하세요 (Markdown이 아닌 순수 HTML)
- 코드 블록(```html 등)이나 추가적인 주석, 설명은 포함하지 마세요
- 바로 사용 가능한 HTML만 출력하세요
"""

                status_text.text(f"🤖 실행 중... ({current_page}/{total_pages}) {page_title}")

                try:
                    # Agent 실행 (강화된 프롬프트 사용)
                    result = agent.generate_page(
                        page_title=page_title,
                        user_prompt=enhanced_prompt,
                        context={}
                    )

                    if result.get('success'):
                        # 섹션 추가
                        st.session_state.builder_sections.append({
                            'type': 'prompt',  # AI 프롬프트 결과
                            'template_id': template_id,
                            'page_index': page_idx,
                            'title': page_title,
                            'category': template.category if template else '기타',
                            'html_content': result.get('content', ''),
                            'order': len(st.session_state.builder_sections),
                            'elapsed_time': result.get('elapsed_time', 0)
                        })
                        success_count += 1
                    else:
                        st.warning(f"⚠️ '{page_title}' 실행 실패: {result.get('error', '알 수 없는 오류')}")

                except Exception as e:
                    st.error(f"❌ '{page_title}' 실행 중 오류: {str(e)}")

                # 진행률 업데이트
                progress_bar.progress(current_page / total_pages)

                # 429 에러 방지 - 다음 페이지 실행 전 대기
                if current_page < total_pages:
                    time.sleep(2)  # 2초 대기

        progress_bar.empty()
        status_text.empty()

        if success_count > 0:
            st.success(f"✅ {success_count}개 페이지 실행 완료! (총 {total_pages}개 중)")

            # 캐시 통계 출력
            try:
                from cached_jira_client import get_total_cache_stats
                cache_stats = get_total_cache_stats()
                st.info(f"""
📊 **Jira API 캐시 통계**
- 총 요청: {cache_stats['total_requests']}건
- 캐시 히트: {cache_stats['cache_hits']}건 (히트율: {cache_stats['hit_rate']})
- API 호출: {cache_stats['api_calls']}건 (절감: {cache_stats['total_requests'] - cache_stats['api_calls']}건)
                """)
            except Exception as e:
                logger.warning(f"캐시 통계 출력 실패: {e}")

            # 선택 해제
            st.session_state.selected_prompts.clear()
            st.rerun()
        else:
            st.error(f"❌ 모든 페이지 실행 실패 (총 {total_pages}개)")

    except Exception as e:
        st.error(f"❌ 실행 중 오류: {str(e)}")
        import traceback
        st.error(traceback.format_exc())
    finally:
        session.close()


def generate_final_html(sections: List[Dict], title: str, include_toc: bool = True) -> str:
    """최종 HTML 보고서 생성 - 다양한 컴포넌트 타입 지원"""
    from datetime import datetime

    html = f"""<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{title}</title>
    <style>
        body {{
            font-family: 'Segoe UI', 'Malgun Gothic', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #333;
            background-color: #f5f5f5;
            margin: 0;
            padding: 20px;
        }}
        .report-container {{
            max-width: 1200px;
            margin: 0 auto;
            background-color: white;
            padding: 40px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }}
        .report-header {{
            text-align: center;
            margin-bottom: 40px;
            padding-bottom: 20px;
            border-bottom: 3px solid #4CAF50;
        }}
        .report-header h1 {{
            color: #2c3e50;
            margin-bottom: 10px;
        }}
        .report-date {{
            color: #7f8c8d;
            font-size: 1.1em;
        }}
        .toc {{
            background-color: #f8f9fa;
            padding: 20px;
            margin-bottom: 30px;
            border-left: 4px solid #4CAF50;
        }}
        .toc h2 {{
            margin-top: 0;
            color: #2c3e50;
        }}
        .toc ol {{
            padding-left: 20px;
        }}
        .toc li {{
            margin: 8px 0;
        }}
        .toc a {{
            color: #3498db;
            text-decoration: none;
        }}
        .toc a:hover {{
            text-decoration: underline;
        }}
        .report-section {{
            margin-bottom: 40px;
        }}
        .report-section h2 {{
            color: #2c3e50;
            border-bottom: 2px solid #4CAF50;
            padding-bottom: 10px;
            margin-bottom: 20px;
        }}
        .section-content {{
            margin: 20px 0;
        }}

        /* 텍스트 스타일 */
        .text-paragraph {{
            line-height: 1.8;
            margin: 15px 0;
        }}
        .text-heading {{
            font-size: 1.5em;
            font-weight: 600;
            color: #2c3e50;
            margin: 20px 0 10px 0;
        }}
        .text-note {{
            background-color: #fff9e6;
            border-left: 4px solid #ffc107;
            padding: 15px;
            margin: 15px 0;
        }}

        /* 표 스타일 */
        table {{
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }}
        table th {{
            background-color: #4CAF50;
            color: white;
            padding: 12px;
            text-align: left;
            font-weight: 600;
        }}
        table td {{
            padding: 10px 12px;
            border-bottom: 1px solid #ddd;
        }}
        table tr:hover {{
            background-color: #f5f5f5;
        }}

        /* 구분선 스타일 */
        .divider-solid {{
            border: none;
            border-top: 1px solid #ccc;
            margin: 30px 0;
        }}
        .divider-dashed {{
            border: none;
            border-top: 1px dashed #ccc;
            margin: 30px 0;
        }}
        .divider-thick {{
            border: none;
            border-top: 3px solid #666;
            margin: 30px 0;
        }}

        /* 페이지 구분 스타일 */
        .page-break {{
            page-break-after: always;
            height: 0;
            margin: 0;
            padding: 0;
        }}

        @media print {{
            body {{
                background-color: white;
                padding: 0;
            }}
            .report-container {{
                box-shadow: none;
            }}
            .page-break {{
                page-break-after: always;
            }}
        }}
    </style>
</head>
<body>
    <div class="report-container">
        <div class="report-header">
            <h1>{title}</h1>
            <p class="report-date">{datetime.now().strftime('%Y-%m-%d')}</p>
        </div>
"""

    # 목차 (divider와 page_break는 제외)
    if include_toc:
        html += '\n<div class="toc">\n'
        html += '<h2>목차</h2>\n'
        html += '<ol>\n'

        section_number = 0
        for section in sections:
            section_type = section.get('type', 'prompt')
            # divider와 page_break는 목차에서 제외
            if section_type not in ['divider', 'page_break']:
                section_number += 1
                section_title = section.get('title', '제목 없음')
                html += f'<li><a href="#section-{section_number}">{section_title}</a></li>\n'

        html += '</ol>\n'
        html += '</div>\n'

    # 각 섹션 생성 (타입별로 다른 HTML)
    section_number = 0
    for section in sections:
        section_type = section.get('type', 'prompt')

        if section_type == 'prompt':
            # AI 프롬프트 결과
            section_number += 1
            section_title = section.get('title', '제목 없음')
            section_content = section.get('html_content', '')
            html += f"""
<section id="section-{section_number}" class="report-section">
    <h2>{section_number}. {section_title}</h2>
    <div class="section-content">
        {section_content}
    </div>
</section>
"""

        elif section_type == 'text':
            # 텍스트 블록
            section_number += 1
            section_title = section.get('title', '텍스트')
            content = section.get('content', '')
            style = section.get('style', 'paragraph')

            # 줄바꿈을 <br>로 변환
            content_html = content.replace('\n', '<br>')

            style_class = f'text-{style}'

            html += f"""
<section id="section-{section_number}" class="report-section">
    <h2>{section_number}. {section_title}</h2>
    <div class="section-content">
        <div class="{style_class}">{content_html}</div>
    </div>
</section>
"""

        elif section_type == 'table':
            # 표
            section_number += 1
            section_title = section.get('title', '표')
            table_data = section.get('data', [[]])

            # HTML 테이블 생성
            table_html = '<table>\n'

            # 첫 행은 헤더로 처리
            if len(table_data) > 0:
                table_html += '<thead>\n<tr>\n'
                for cell in table_data[0]:
                    table_html += f'<th>{cell}</th>\n'
                table_html += '</tr>\n</thead>\n'

            # 나머지 행은 데이터
            if len(table_data) > 1:
                table_html += '<tbody>\n'
                for row in table_data[1:]:
                    table_html += '<tr>\n'
                    for cell in row:
                        table_html += f'<td>{cell}</td>\n'
                    table_html += '</tr>\n'
                table_html += '</tbody>\n'

            table_html += '</table>\n'

            html += f"""
<section id="section-{section_number}" class="report-section">
    <h2>{section_number}. {section_title}</h2>
    <div class="section-content">
        {table_html}
    </div>
</section>
"""

        elif section_type == 'divider':
            # 구분선 (섹션 번호 없음, 목차에도 없음)
            style = section.get('style', 'solid')
            html += f'<hr class="divider-{style}">\n'

        elif section_type == 'page_break':
            # 페이지 구분 (섹션 번호 없음, 목차에도 없음)
            html += '<div class="page-break"></div>\n'

    html += """
    </div>
</body>
</html>
"""

    return html


def display_group_management():
    """그룹 관리 UI"""
    st.header("👥 그룹 관리")

    if not auth_client.is_logged_in():
        st.warning("⚠️ 로그인이 필요합니다")
        return

    st.info("""
💡 **그룹 협업 기능**
- 팀원들과 함께 그룹을 만들고 프롬프트를 공유할 수 있습니다
- 각 멤버가 담당하는 시스템(NCMS, EUXP, EDMP 등)을 설정할 수 있습니다
- 그룹 보고서를 생성하면 시스템별로 자동 통합됩니다
    """)

    # 세션 상태 초기화
    if 'selected_group_id' not in st.session_state:
        st.session_state.selected_group_id = None
    if 'show_create_group_form' not in st.session_state:
        st.session_state.show_create_group_form = False

    # 그룹 목록 조회
    groups_result = auth_client.get_groups()

    if not groups_result.get("success"):
        st.error(f"그룹 목록을 불러올 수 없습니다: {groups_result.get('message')}")
        return

    groups = groups_result.get("groups", [])

    # 그룹 생성 버튼
    col1, col2 = st.columns([3, 1])
    with col2:
        if st.button("+ 새 그룹 만들기", use_container_width=True):
            st.session_state.show_create_group_form = True
            st.rerun()

    # 그룹 생성 폼
    if st.session_state.show_create_group_form:
        with st.form("create_group_form"):
            st.subheader("새 그룹 만들기")
            group_name = st.text_input("그룹 이름 *", placeholder="예: OTT운영팀")
            group_description = st.text_area("설명", placeholder="그룹에 대한 간단한 설명")

            col_submit, col_cancel = st.columns(2)
            with col_submit:
                submitted = st.form_submit_button("생성", use_container_width=True)
            with col_cancel:
                if st.form_submit_button("취소", use_container_width=True):
                    st.session_state.show_create_group_form = False
                    st.rerun()

            if submitted:
                if not group_name.strip():
                    st.error("그룹 이름을 입력해주세요")
                else:
                    result = auth_client.create_group(group_name.strip(), group_description.strip() or None)
                    if result.get("success"):
                        st.success(f"✅ 그룹 '{group_name}'이 생성되었습니다!")
                        st.session_state.show_create_group_form = False
                        st.rerun()
                    else:
                        st.error(f"그룹 생성 실패: {result.get('message')}")

    st.markdown("---")

    # 그룹 목록
    if not groups:
        st.info("아직 그룹이 없습니다. 새 그룹을 만들어보세요!")
        return

    # 그룹이 선택되지 않은 경우: 그룹 목록 표시
    if not st.session_state.selected_group_id:
        st.subheader("내 그룹")

        for group in groups:
            with st.container():
                col1, col2, col3 = st.columns([3, 1, 1])

                with col1:
                    st.markdown(f"### {group['name']}")
                    if group.get('description'):
                        st.caption(group['description'])

                with col2:
                    role_emoji = "👑" if group['role'] == 'owner' else "👤"
                    role_text = "Owner" if group['role'] == 'owner' else "Member"
                    st.info(f"{role_emoji} {role_text}")

                with col3:
                    if st.button("상세보기", key=f"view_{group['id']}", use_container_width=True):
                        st.session_state.selected_group_id = group['id']
                        st.rerun()

                # 그룹 정보
                info_col1, info_col2 = st.columns(2)
                with info_col1:
                    st.caption(f"👥 {group.get('member_count', 0)}명")
                with info_col2:
                    st.caption(f"📝 {group.get('prompt_count', 0)}개 프롬프트")

                st.markdown("---")

    # 그룹이 선택된 경우: 그룹 상세 정보
    else:
        if st.button("← 그룹 목록으로"):
            st.session_state.selected_group_id = None
            st.rerun()

        # 그룹 상세 정보 조회
        detail_result = auth_client.get_group_detail(st.session_state.selected_group_id)

        if not detail_result.get("success"):
            st.error(f"그룹 정보를 불러올 수 없습니다: {detail_result.get('message')}")
            st.session_state.selected_group_id = None
            return

        group_data = detail_result.get("data", {})
        group_info = group_data.get("group", {})
        members = group_data.get("members", [])
        prompts = group_data.get("prompts", [])

        st.subheader(f"📁 {group_info.get('name')}")
        if group_info.get('description'):
            st.caption(group_info['description'])

        # 탭 구성
        tab1, tab2, tab3, tab4 = st.tabs(["👥 멤버", "📝 프롬프트", "📂 카테고리", "⚙️ 설정"])

        with tab1:
            st.subheader("그룹 멤버")

            # Owner만 멤버 추가 가능
            if group_info.get('role') == 'owner':
                with st.expander("➕ 멤버 추가"):
                    with st.form("add_member_form"):
                        new_user_id = st.number_input("사용자 ID", min_value=1, step=1)
                        system = st.text_input("담당 시스템 (선택)", placeholder="예: NCMS, EUXP, EDMP")

                        if st.form_submit_button("추가"):
                            result = auth_client.add_group_member(
                                st.session_state.selected_group_id,
                                new_user_id,
                                system.strip() or None
                            )
                            if result.get("success"):
                                st.success("✅ 멤버가 추가되었습니다!")
                                st.rerun()
                            else:
                                st.error(f"멤버 추가 실패: {result.get('message')}")

            # 멤버 목록
            if members:
                for member in members:
                    col1, col2, col3, col4 = st.columns([2, 1, 1, 1])

                    with col1:
                        role_badge = "👑 Owner" if member['role'] == 'owner' else "👤 Member"
                        username = member.get('username', member.get('email', 'Unknown'))
                        st.markdown(f"**{username}** {role_badge}")
                        st.caption(f"Email: {member.get('email', 'N/A')}")

                    with col2:
                        if member.get('system'):
                            st.info(f"📌 {member['system']}")

                    with col3:
                        st.caption(f"가입: {member['joined_at'][:10]}")

                    with col4:
                        # Owner만 멤버 제거 가능 (본인 제외)
                        if group_info.get('role') == 'owner' and member['role'] != 'owner':
                            if st.button("제거", key=f"remove_{member['user_id']}"):
                                result = auth_client.remove_group_member(
                                    st.session_state.selected_group_id,
                                    member['user_id']
                                )
                                if result.get("success"):
                                    st.success("✅ 멤버가 제거되었습니다!")
                                    st.rerun()
                                else:
                                    st.error(f"멤버 제거 실패: {result.get('message')}")

                    st.markdown("---")
            else:
                st.info("아직 멤버가 없습니다")

        with tab2:
            st.subheader("그룹 프롬프트")

            prompts_by_category = group_data.get("prompts_by_category", {})

            if prompts_by_category:
                for category, category_prompts in prompts_by_category.items():
                    st.markdown(f"### 📂 {category}")

                    for prompt in category_prompts:
                        with st.expander(f"📝 {prompt['title']} ({prompt['owner']})"):
                            if prompt.get('description'):
                                st.caption(prompt['description'])

                            if prompt.get('system'):
                                st.info(f"담당 시스템: {prompt['system']}")

                            if prompt.get('prompt_content'):
                                st.code(prompt['prompt_content'], language="markdown")
                            else:
                                st.warning("프롬프트 내용을 불러올 수 없습니다")

                            st.caption(f"작성일: {prompt.get('created_at', 'N/A')[:10] if prompt.get('created_at') else 'N/A'}")
            else:
                st.info("아직 작성된 프롬프트가 없습니다")
                st.caption("프롬프트 관리 탭에서 그룹 프롬프트를 작성할 수 있습니다")

        with tab3:
            st.subheader("그룹 카테고리")

            st.info("""
💡 **카테고리란?**
- 그룹의 프롬프트를 분류하는 카테고리를 정의할 수 있습니다
- Owner만 카테고리를 추가/수정/삭제할 수 있습니다
- 멤버는 정의된 카테고리 중에서 선택하여 프롬프트를 작성합니다
- 카테고리 순서를 조정하여 보고서 내 표시 순서를 결정합니다
            """)

            # 카테고리 목록 조회
            categories = group_data.get("categories", [])

            # Owner만 카테고리 관리 가능
            if group_data.get("my_role") == 'owner':
                with st.expander("➕ 카테고리 추가"):
                    with st.form("add_category_form"):
                        cat_name = st.text_input("카테고리 이름 *", placeholder="예: 운영지원, BMT, PM")
                        cat_description = st.text_area("설명 (선택)", placeholder="카테고리에 대한 설명")
                        cat_order = st.number_input("순서", min_value=0, value=len(categories), step=1,
                                                   help="낮은 숫자가 먼저 표시됩니다")

                        if st.form_submit_button("추가"):
                            if not cat_name.strip():
                                st.error("카테고리 이름을 입력해주세요")
                            else:
                                result = auth_client.add_group_category(
                                    st.session_state.selected_group_id,
                                    cat_name.strip(),
                                    cat_description.strip() or None,
                                    cat_order
                                )
                                if result.get("success"):
                                    st.success(f"✅ 카테고리 '{cat_name}'이 추가되었습니다!")
                                    st.rerun()
                                else:
                                    st.error(f"카테고리 추가 실패: {result.get('message')}")

            # 카테고리 목록 표시
            if categories:
                st.markdown("### 📂 현재 카테고리")

                for idx, category in enumerate(categories):
                    with st.container():
                        col1, col2, col3 = st.columns([3, 1, 1])

                        with col1:
                            st.markdown(f"**{category['name']}** (순서: {category['order_index']})")
                            if category.get('description'):
                                st.caption(category['description'])

                        with col2:
                            # Owner만 편집 가능
                            if group_data.get("my_role") == 'owner':
                                edit_key = f"edit_cat_{category['id']}"
                                if edit_key not in st.session_state:
                                    st.session_state[edit_key] = False

                                if st.button("✏️", key=f"btn_edit_{category['id']}", use_container_width=True):
                                    st.session_state[edit_key] = not st.session_state[edit_key]
                                    st.rerun()

                        with col3:
                            # Owner만 삭제 가능
                            if group_data.get("my_role") == 'owner':
                                if st.button("🗑️", key=f"btn_del_{category['id']}", use_container_width=True):
                                    result = auth_client.delete_group_category(
                                        st.session_state.selected_group_id,
                                        category['id']
                                    )
                                    if result.get("success"):
                                        st.success("✅ 카테고리가 삭제되었습니다!")
                                        st.rerun()
                                    else:
                                        st.error(f"카테고리 삭제 실패: {result.get('message')}")

                        # 편집 폼
                        if group_data.get("my_role") == 'owner' and st.session_state.get(f"edit_cat_{category['id']}", False):
                            with st.form(f"edit_cat_form_{category['id']}"):
                                new_name = st.text_input("카테고리 이름", value=category['name'])
                                new_desc = st.text_area("설명", value=category.get('description', ''))

                                col_save, col_cancel = st.columns(2)
                                with col_save:
                                    if st.form_submit_button("저장"):
                                        result = auth_client.update_group_category(
                                            st.session_state.selected_group_id,
                                            category['id'],
                                            new_name.strip() or None,
                                            new_desc.strip() or None
                                        )
                                        if result.get("success"):
                                            st.success("✅ 카테고리가 수정되었습니다!")
                                            st.session_state[f"edit_cat_{category['id']}"] = False
                                            st.rerun()
                                        else:
                                            st.error(f"카테고리 수정 실패: {result.get('message')}")

                                with col_cancel:
                                    if st.form_submit_button("취소"):
                                        st.session_state[f"edit_cat_{category['id']}"] = False
                                        st.rerun()

                        st.markdown("---")
            else:
                st.info("아직 정의된 카테고리가 없습니다")
                if group_data.get("my_role") == 'owner':
                    st.caption("카테고리를 추가하여 프롬프트를 분류하세요")
                else:
                    st.caption("Owner가 카테고리를 정의할 때까지 기다려주세요")

        with tab4:
            st.subheader("그룹 설정")

            # Owner만 수정/삭제 가능
            if group_info.get('role') == 'owner':
                with st.expander("✏️ 그룹 정보 수정"):
                    with st.form("update_group_form"):
                        new_name = st.text_input("그룹 이름", value=group_info.get('name'))
                        new_description = st.text_area("설명", value=group_info.get('description', ''))

                        if st.form_submit_button("수정"):
                            result = auth_client.update_group(
                                st.session_state.selected_group_id,
                                new_name.strip() or None,
                                new_description.strip() or None
                            )
                            if result.get("success"):
                                st.success("✅ 그룹 정보가 수정되었습니다!")
                                st.rerun()
                            else:
                                st.error(f"그룹 수정 실패: {result.get('message')}")

                st.markdown("---")

                with st.expander("🗑️ 그룹 삭제"):
                    st.warning("⚠️ 그룹을 삭제하면 복구할 수 없습니다!")

                    confirm_text = st.text_input("삭제하려면 그룹 이름을 입력하세요")

                    if st.button("그룹 삭제", type="primary"):
                        if confirm_text == group_info.get('name'):
                            result = auth_client.delete_group(st.session_state.selected_group_id)
                            if result.get("success"):
                                st.success("✅ 그룹이 삭제되었습니다!")
                                st.session_state.selected_group_id = None
                                st.rerun()
                            else:
                                st.error(f"그룹 삭제 실패: {result.get('message')}")
                        else:
                            st.error("그룹 이름이 일치하지 않습니다")
            else:
                st.info("👤 멤버는 그룹 설정을 변경할 수 없습니다")


def display_group_report_builder():
    """그룹 보고서 생성 UI"""
    st.header("📊 그룹 보고서 생성")

    if not auth_client.is_logged_in():
        st.warning("⚠️ 로그인이 필요합니다")
        return

    st.info("""
💡 **그룹 보고서란?**
- 그룹 멤버들이 작성한 프롬프트를 모아서 하나의 통합 보고서를 생성합니다
- 각 멤버가 담당하는 시스템(NCMS, EUXP, EDMP 등)별로 자동 정렬됩니다
- 카테고리 > 시스템 순서로 구조화되어 보기 쉽습니다
    """)

    # 세션 상태 초기화
    if 'group_report_selected_group_id' not in st.session_state:
        st.session_state.group_report_selected_group_id = None
    if 'group_report_html' not in st.session_state:
        st.session_state.group_report_html = None

    # 1단계: 그룹 선택
    st.subheader("1️⃣ 그룹 선택")

    groups_result = auth_client.get_groups()

    if not groups_result.get("success"):
        st.error(f"그룹 목록을 불러올 수 없습니다: {groups_result.get('message')}")
        return

    groups = groups_result.get("groups", [])

    if not groups:
        st.info("아직 그룹이 없습니다. 그룹 관리 탭에서 새 그룹을 만들어보세요!")
        return

    # 그룹 선택 드롭다운
    group_options = {group['id']: f"{group['name']} ({group.get('member_count', 0)}명, {group.get('prompt_count', 0)}개 프롬프트)" for group in groups}

    selected_group_id = st.selectbox(
        "그룹 선택",
        options=list(group_options.keys()),
        format_func=lambda x: group_options[x],
        key="group_report_select"
    )

    if not selected_group_id:
        return

    # 그룹 상세 정보 조회
    detail_result = auth_client.get_group_detail(selected_group_id)

    if not detail_result.get("success"):
        st.error(f"그룹 정보를 불러올 수 없습니다: {detail_result.get('message')}")
        return

    group_data = detail_result.get("data", {})
    group_info = group_data.get("group", {})
    prompts_by_category = group_data.get("prompts_by_category", {})

    if not prompts_by_category:
        st.warning("이 그룹에는 아직 프롬프트가 없습니다. 프롬프트 관리 탭에서 그룹 프롬프트를 작성해주세요.")
        return

    st.markdown("---")

    # 2단계: 프롬프트 선택
    st.subheader("2️⃣ 프롬프트 선택")

    # 전체 선택/해제 버튼
    col1, col2, col3 = st.columns([1, 1, 3])
    with col1:
        if st.button("전체 선택"):
            for category in prompts_by_category.keys():
                for prompt in prompts_by_category[category]:
                    st.session_state[f"prompt_check_{prompt['id']}"] = True
            st.rerun()
    with col2:
        if st.button("전체 해제"):
            for category in prompts_by_category.keys():
                for prompt in prompts_by_category[category]:
                    st.session_state[f"prompt_check_{prompt['id']}"] = False
            st.rerun()

    # 카테고리별 프롬프트 선택
    selected_prompts = []

    for category, category_prompts in prompts_by_category.items():
        st.markdown(f"### 📂 {category}")

        # 카테고리 전체 선택
        if st.checkbox(f"카테고리 전체 선택", key=f"cat_check_{category}"):
            for prompt in category_prompts:
                st.session_state[f"prompt_check_{prompt['id']}"] = True

        # 시스템별 그룹핑
        prompts_by_system = {}
        for prompt in category_prompts:
            system = prompt.get('system', '기타')
            if system not in prompts_by_system:
                prompts_by_system[system] = []
            prompts_by_system[system].append(prompt)

        # 시스템별 표시
        for system, system_prompts in prompts_by_system.items():
            with st.expander(f"📌 {system} ({len(system_prompts)}개)"):
                for prompt in system_prompts:
                    checked = st.checkbox(
                        f"{prompt['title']} (by {prompt['owner']})",
                        key=f"prompt_check_{prompt['id']}",
                        value=st.session_state.get(f"prompt_check_{prompt['id']}", False)
                    )
                    if checked:
                        selected_prompts.append(prompt['id'])

                    if prompt.get('description'):
                        st.caption(prompt['description'])

    st.markdown("---")

    # 3단계: 보고서 설정
    st.subheader("3️⃣ 보고서 설정")

    col1, col2 = st.columns(2)
    with col1:
        report_title = st.text_input("보고서 제목", value=f"{group_info.get('name')} 월간보고", key="group_report_title")
    with col2:
        include_toc = st.checkbox("목차 포함", value=True, key="group_include_toc")
        save_report = st.checkbox("히스토리 저장", value=True, key="group_save_report")

    st.caption(f"선택된 프롬프트: {len(selected_prompts)}개")

    # 4단계: 보고서 생성
    if len(selected_prompts) == 0:
        st.warning("⚠️ 최소 1개 이상의 프롬프트를 선택해주세요")
    else:
        if st.button("🚀 그룹 보고서 생성", type="primary", use_container_width=True):
            with st.spinner("그룹 보고서를 생성하는 중입니다... 시간이 다소 걸릴 수 있습니다."):
                result = auth_client.generate_group_report(
                    group_id=selected_group_id,
                    title=report_title,
                    prompt_ids=selected_prompts,
                    include_toc=include_toc,
                    save=save_report
                )

                if result.get("success"):
                    st.session_state.group_report_html = result.get("html")
                    st.success(f"✅ 그룹 보고서가 생성되었습니다! ({len(selected_prompts)}개 프롬프트)")

                    if save_report:
                        st.info(f"📁 보고서 ID: {result.get('report_id')}")
                else:
                    st.error(f"보고서 생성 실패: {result.get('message')}")

    # 5단계: 미리보기 및 다운로드
    if st.session_state.group_report_html:
        st.markdown("---")
        st.subheader("📄 생성된 보고서")

        # 다운로드 버튼
        st.download_button(
            label="💾 HTML 다운로드",
            data=st.session_state.group_report_html,
            file_name=f"group_report_{group_info.get('name')}_{datetime.now().strftime('%Y%m%d')}.html",
            mime="text/html",
            use_container_width=True
        )

        # 미리보기
        with st.expander("미리보기", expanded=True):
            st.components.v1.html(st.session_state.group_report_html, height=600, scrolling=True)


def display_jira_debugging():
    """Jira 디버깅 UI - search_issues와 get_linked_issues 테스트"""
    st.header("🔍 Jira 이슈 검색 디버깅")

    st.info("💡 search_issues와 get_linked_issues 함수를 테스트하여 연결된 이슈 정보를 확인할 수 있습니다.")

    # 중요 안내
    st.warning("""
⚠️ **JQL 작성 시 주의사항**

1. **따옴표**: 필드 값에는 **큰따옴표 `"`** 사용
   - ✅ 올바름: `labels = "NCMS_BMT"`
   - ❌ 잘못됨: `labels = 'NCMS_BMT'`
   - 💡 작은따옴표는 자동으로 큰따옴표로 변환됩니다

2. **fixVersion**: JQL에서는 **단수형** 사용 (중요!)
   - ✅ 올바름: `fixVersion = "25.05"`
   - ❌ 잘못됨: `fixVersions = "25.05"`
   - 📝 참고: fields 파라미터와 반환 데이터는 `fixVersions` (복수형)
    """)

    # 로그인 사용자 정보 확인
    user_info = auth_client.get_current_user()
    if not user_info or 'id' not in user_info:
        st.error("❌ 로그인이 필요합니다.")
        st.stop()

    user_id = user_info['id']
    st.caption(f"👤 로그인 사용자 ID: {user_id}")

    # JQL 입력
    st.subheader("1️⃣ JQL 쿼리")

    # JQL 예시 선택
    with st.expander("📝 JQL 예시 선택"):
        jql_examples = {
            "프로젝트 + 라벨 + 버전": 'project = BTVO AND labels = "NCMS_BMT" AND fixVersion = "25.05"',
            "프로젝트 + 라벨": 'project = BTVO AND labels = "NCMS_BMT"',
            "프로젝트 + 버전": 'project = BTVO AND fixVersion = "25.05"',
            "프로젝트 + 상태": 'project = BTVO AND status = "완료"',
            "프로젝트 + 담당자": 'project = BTVO AND assignee = currentUser()',
            "날짜 범위": 'project = BTVO AND created >= "2025-10-01" AND created <= "2025-10-31"',
            "여러 라벨 (OR)": 'project = BTVO AND labels in ("NCMS_BMT", "NCMS_PM")',
            "여러 버전 (OR)": 'project = BTVO AND fixVersion in ("25.05", "25.06")',
        }

        selected_example = st.selectbox(
            "예시를 선택하면 아래 입력란에 자동으로 채워집니다",
            options=["선택하세요"] + list(jql_examples.keys())
        )

        if selected_example != "선택하세요":
            st.session_state['jql_example'] = jql_examples[selected_example]
            st.rerun()

    # JQL 입력란
    default_jql = st.session_state.pop('jql_example', 'project = BTVO AND labels = "NCMS_BMT" AND fixVersion = "25.05"')

    jql_input = st.text_area(
        "JQL 쿼리를 입력하세요",
        value=default_jql,
        height=100,
        help="Jira Query Language 쿼리 (큰따옴표 사용, fixVersion은 단수형!)"
    )

    max_results = st.number_input(
        "최대 결과 개수",
        min_value=1,
        max_value=100,
        value=10,
        help="조회할 최대 이슈 개수"
    )

    # issuelinks 포함 옵션
    include_issuelinks = st.checkbox(
        "🔗 issuelinks 필드 포함 (연결된 이슈 정보)",
        value=True,
        help="체크하면 원시 API 응답에 issuelinks 필드가 포함됩니다"
    )

    col_search1, col_search2 = st.columns(2)

    with col_search1:
        if st.button("🔍 이슈 검색", type="primary", use_container_width=True):
            with st.spinner("Jira 이슈 검색 중..."):
                try:
                    from tools.jira_query_tool import JiraQueryTool

                    # JiraQueryTool로 직접 검색 (원시 데이터 접근)
                    tool = JiraQueryTool(user_id=user_id)
                    client = tool.client

                    # 필드 설정
                    fields = [
                        "key",
                        "summary",
                        "status",
                        "assignee",
                        "reporter",
                        "created",
                        "updated",
                        "priority",
                        "labels",
                        "components",
                        "issuetype",
                        "fixVersions",
                    ]

                    # issuelinks 추가
                    if include_issuelinks:
                        fields.append("issuelinks")

                    # 원시 API 호출
                    issues_raw = client.search_issues(
                        jql=jql_input,
                        max_results=max_results,
                        fields=fields
                    )

                    # 세션에 저장 (원시 + 파싱 데이터 모두)
                    st.session_state['debug_issues_raw'] = issues_raw
                    st.session_state['debug_jql'] = jql_input

                    # 파싱된 데이터 생성 (UI 표시용)
                    from tools.jira_tools import _parse_issue
                    issues_parsed = []
                    for issue_raw in issues_raw:
                        parsed = _parse_issue(issue_raw)
                        if parsed:
                            issues_parsed.append(parsed)

                    st.session_state['debug_issues'] = issues_parsed

                    if issues_raw:
                        st.success(f"✅ {len(issues_raw)}개 이슈를 찾았습니다!")
                        if include_issuelinks:
                            # issuelinks 통계
                            issues_with_links = sum(
                                1 for issue in issues_raw
                                if issue.get("fields", {}).get("issuelinks")
                            )
                            st.info(f"🔗 {issues_with_links}개 이슈에 연결된 이슈가 있습니다")
                    else:
                        st.warning("⚠️ 조회된 이슈가 없습니다.")

                except Exception as e:
                    st.error(f"❌ 검색 중 오류: {str(e)}")
                    st.exception(e)

    with col_search2:
        if st.button("🗑️ 결과 초기화", use_container_width=True):
            for key in list(st.session_state.keys()):
                if key.startswith('debug_'):
                    del st.session_state[key]
            st.rerun()

    # 검색 결과 표시
    if st.session_state.get('debug_issues'):
        issues = st.session_state['debug_issues']

        st.divider()
        st.subheader(f"2️⃣ 검색 결과 ({len(issues)}개)")

        # 통계 정보
        col_stat1, col_stat2, col_stat3, col_stat4 = st.columns(4)
        with col_stat1:
            st.metric("총 이슈 수", len(issues))
        with col_stat2:
            status_counts = {}
            for issue in issues:
                status = issue.get('status', 'Unknown')
                status_counts[status] = status_counts.get(status, 0) + 1
            st.metric("상태 종류", len(status_counts))
        with col_stat3:
            assignees = set(issue.get('assignee') for issue in issues if issue.get('assignee'))
            st.metric("담당자 수", len(assignees))
        with col_stat4:
            with_labels = sum(1 for issue in issues if issue.get('labels'))
            st.metric("라벨 있는 이슈", with_labels)

        # 이슈 목록을 테이블로 표시
        st.subheader("📋 이슈 목록")

        table_data = []
        for issue in issues:
            table_data.append({
                "Key": issue.get("key", ""),
                "Summary": (issue.get("summary", "")[:60] + "...") if len(issue.get("summary", "")) > 60 else issue.get("summary", ""),
                "Status": issue.get("status", ""),
                "Assignee": issue.get("assignee", "Unassigned"),
                "Created": issue.get("created", "")[:10] if issue.get("created") else "",
                "Labels": ", ".join(issue.get("labels", [])[:3])
            })

        st.dataframe(table_data, use_container_width=True, height=400)

        # 이슈 선택
        st.divider()
        st.subheader("3️⃣ 연결된 이슈 확인")

        issue_keys = [issue.get("key", "") for issue in issues]
        selected_key = st.selectbox(
            "이슈를 선택하여 연결된 이슈를 확인하세요",
            options=["선택하세요"] + issue_keys
        )

        if selected_key and selected_key != "선택하세요":
            # 선택된 이슈 정보 표시
            selected_issue = next((issue for issue in issues if issue.get("key") == selected_key), None)

            if selected_issue:
                st.session_state['debug_selected_issue'] = selected_issue

                col_detail1, col_detail2 = st.columns([2, 1])

                with col_detail1:
                    st.info(f"""
**Key**: {selected_issue.get('key')}
**Summary**: {selected_issue.get('summary')}
**Status**: {selected_issue.get('status')}
**Assignee**: {selected_issue.get('assignee', 'Unassigned')}
**Labels**: {', '.join(selected_issue.get('labels', [])) if selected_issue.get('labels') else 'None'}
                    """)

                with col_detail2:
                    # search 결과에서 issuelinks 먼저 확인
                    raw_issue = None
                    if st.session_state.get('debug_issues_raw'):
                        raw_issue = next(
                            (issue for issue in st.session_state['debug_issues_raw']
                             if issue.get("key") == selected_key),
                            None
                        )

                    # issuelinks가 search 결과에 있으면 바로 표시
                    if raw_issue and raw_issue.get("fields", {}).get("issuelinks"):
                        issuelinks = raw_issue["fields"]["issuelinks"]
                        st.info(f"🔗 Search 결과에 {len(issuelinks)}개 링크 포함")

                        # 자동으로 표시
                        st.session_state['debug_raw_issuelinks'] = issuelinks

                    if st.button("🔗 연결된 이슈 조회 (API)", type="primary", use_container_width=True):
                        with st.spinner("연결된 이슈 조회 중..."):
                            try:
                                from tools.jira_tools import get_linked_issues

                                linked_issues = get_linked_issues(
                                    user_id=user_id,
                                    issue_key=selected_key
                                )

                                st.session_state['debug_linked_issues'] = linked_issues

                                if linked_issues:
                                    st.success(f"✅ {len(linked_issues)}개의 연결된 이슈를 찾았습니다!")
                                else:
                                    st.warning("⚠️ 연결된 이슈가 없습니다.")

                            except Exception as e:
                                st.error(f"❌ 연결된 이슈 조회 중 오류: {str(e)}")
                                st.exception(e)

                # Search 결과에 포함된 issuelinks 표시
                if st.session_state.get('debug_raw_issuelinks'):
                    st.divider()
                    st.subheader("🔗 Search 결과의 issuelinks (원시)")

                    raw_links = st.session_state['debug_raw_issuelinks']

                    for i, link in enumerate(raw_links, 1):
                        link_type = link.get("type", {}).get("name", "Unknown")

                        # outward 또는 inward 확인
                        if "outwardIssue" in link:
                            direction = "outward ➡️"
                            linked_issue = link["outwardIssue"]
                        elif "inwardIssue" in link:
                            direction = "inward ⬅️"
                            linked_issue = link["inwardIssue"]
                        else:
                            continue

                        with st.expander(f"{i}. {linked_issue.get('key')} - {link_type} ({direction})", expanded=True):
                            st.markdown(f"""
**Key**: `{linked_issue.get('key')}`
**Summary**: {linked_issue.get('fields', {}).get('summary', 'N/A')}
**Status**: {linked_issue.get('fields', {}).get('status', {}).get('name', 'N/A')}
**Link Type**: {link_type}
**Direction**: {direction}
                            """)

                            st.caption("원시 link 데이터:")
                            st.json(link)

                # 연결된 이슈 표시 (get_linked_issues API 결과)
                if st.session_state.get('debug_linked_issues'):
                    linked_issues = st.session_state['debug_linked_issues']

                    st.divider()
                    st.subheader(f"🔗 get_linked_issues() API 결과 ({len(linked_issues)}개)")
                    st.caption("get_linked_issues 함수로 조회한 파싱된 데이터")

                    if linked_issues:
                        for i, linked in enumerate(linked_issues, 1):
                            link_type = linked.get('link_type', 'Unknown')
                            link_direction = linked.get('link_direction', 'unknown')

                            direction_icon = "➡️" if link_direction == "outward" else "⬅️"

                            with st.expander(f"{direction_icon} {i}. {linked.get('key')} - {link_type}", expanded=False):
                                col_link1, col_link2 = st.columns([3, 1])

                                with col_link1:
                                    st.markdown(f"""
**Key**: `{linked.get('key')}`
**Summary**: {linked.get('summary')}
**Status**: {linked.get('status')}
**Link Type**: {link_type} ({link_direction})
**Assignee**: {linked.get('assignee', 'Unassigned')}
**Priority**: {linked.get('priority', 'None')}
**Created**: {linked.get('created', '')[:10] if linked.get('created') else 'N/A'}
                                    """)

                                    if linked.get('labels'):
                                        st.markdown(f"**Labels**: {', '.join(linked.get('labels'))}")

                                with col_link2:
                                    st.caption("원시 데이터:")
                                    st.json({
                                        "key": linked.get('key'),
                                        "link_type": link_type,
                                        "link_direction": link_direction,
                                        "status": linked.get('status')
                                    })
                    else:
                        st.info("이 이슈에는 연결된 이슈가 없습니다.")

        # 원시 JSON 데이터 보기
        st.divider()
        st.subheader("🔍 JSON 데이터")

        data_view_tabs = st.tabs(["📋 파싱된 데이터 (UI용)", "🔧 원시 API 응답"])

        with data_view_tabs[0]:
            st.caption("_parse_issue()를 거친 데이터 (필터링됨)")
            st.json(issues)

        with data_view_tabs[1]:
            if st.session_state.get('debug_issues_raw'):
                issues_raw = st.session_state['debug_issues_raw']
                st.caption("Jira API 원본 응답 (필터링 전)")

                # issuelinks 필드 확인
                issues_with_links = []
                for issue in issues_raw:
                    issuelinks = issue.get("fields", {}).get("issuelinks")
                    if issuelinks:
                        issues_with_links.append({
                            "key": issue.get("key"),
                            "link_count": len(issuelinks)
                        })

                if issues_with_links:
                    st.success(f"✅ {len(issues_with_links)}개 이슈에 issuelinks 필드가 있습니다!")
                    st.json({"issues_with_links": issues_with_links})
                else:
                    st.warning("⚠️ 모든 이슈에 issuelinks 필드가 비어있거나 없습니다")

                # 전체 원시 데이터
                st.caption("전체 원시 데이터:")
                st.json(issues_raw)
            else:
                st.info("검색을 실행하면 원시 API 응답을 볼 수 있습니다")


def _validate_report_period(period: str) -> bool:
    """보고 기간 형식 검증 (YYYY-MM)"""
    try:
        parts = period.split('-')
        if len(parts) != 2:
            return False
        year, month = parts
        if len(year) != 4 or not year.isdigit():
            return False
        if len(month) != 2 or not month.isdigit():
            return False
        month_int = int(month)
        if month_int < 1 or month_int > 12:
            return False
        return True
    except:
        return False

if __name__ == "__main__":
    main()
